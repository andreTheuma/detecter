--8<-- "includes/common.md"

# Runtime Verification
---

## A partial view of the program model

Let us recall the calculator server and its transition model.

--8<-- "includes/model.svg"
{: .center .img }

From its initial state `Q0`, the transition system modelling the behaviour of `#!erlang calc_server:loop/1` can follow three different paths.
This *branching* structure is induced by the `#!erlang receive` expression, that introduces a *choice* between which clause to execute, depending on the pattern match that succeeds.
The transition model thus gives us an *exhaustive description* of the paths that the calculator server can take at runtime, affording us *full visibility* about what the program is able to do.
Notably, this information is available prior to runtime, and is what certain static verification techniques such as model checking rely upon.

There are however cases where static approaches cannot be employed, *e.g.* the program transition model is not available, or is infeasible to construct.
*Runtime Verification* is a post-deployment technique [] that can be used instead of---or in tandem with---static techniques to increase correctness assurances about a program under scrutiny.
detectEr is one such RV tool for asynchronous component systems that can analyse the behaviour of programs running on, or outside the EVM.

Post-deployment verification techniques such as RV often to not have access to the entire transition model of a program.
Rather, their view of the system is limited to just to the sequence of events generated by the *current* program execution.
This linear sequence of program event is known as the *execution trace*, or *trace*, for short.
For instance, our calculator program might generate the trace of events '`#!erlang <0.10.0> ? {<0.16.0>, stp}`.`#!erlang <0.10.0>:<0.16.0> ! {bye, 1}`'.
This corresponds to the (finite) path traversal `Q0` --> `#!erlang Srv ? {Clt, stp}` --> `Q3` --> `Srv:Clt ! {bye, Tot}` in the transition model above, where `#!erlang Srv = <0.10.0>`, `#!erlang Clt = <0.16.0>`, and `Tot = 1`.  

## Is one trace enough?

One natural question that may occur to you at this point is whether a mere sliver of the (more expressive) program transition model is sufficient for us to conclude anything of value about the program under analysis.
Answers to this question depend on various aspects:

* _What logic are we using to express properties?_
  There are logics that can reason about states of the program transition model (*e.g.* μ-calculus, HML, CTL), while others can only reason on traces (*e.g.*, LTL).

* _Are the traces we consider finite or infinite?_
  There are logics that can {--Adrian fill in--}

* _How many traces do we have available?_
  There are cases where more than one trace is available, *e.g.* the program is executed multiple times, or the program consists of concurrent components that produce different interleaved executions.
  This produces additional runtime information that we can leverage.

This field of study is called *monitorability*, and has been treated at length in various works[REFS].
For us, it is enough to know that sHML---the logic detectEr uses---is runtime monitorable with respect to *violations* [REFS].
This means that any program that violates a property expressed as a sHML formula can be detected by analysing just one trace {==check==}.
The intuition as to why this is the case is as follows.
Recall that the sHML formula `#!shml [α]φ` requires that *all* the outgoing paths from some state of the program transition system satisfy the symbolic action `#!shml α`, and the next state then satisfies the continuation `#!shml φ`.
To show that a program transition system (*not* just one path!) violates the sHML property, it suffices to find *one* path in the transition system that goes against the what property stipulates.

## Trace events, in practice

When it comes to tooling, the representation of trace events tends to be implementation-specific and is often tied to the chosen language framework.
To make the specification of sHML properties intuitive, detectEr employs the *intermediate representation* seen [earlier](the-specification-logic.md#pattern-and-constraint-expressions), consisting of the program events, `fork`, `init`, `exit`, `send` and `recv`.
detectEr translates this intermediate representation to the format used by the native tracing infrastructure of the EVM, and is covered in the [Synthesising Analysers](synthesising-analysers.md) section.

---
We next learn how the [safety properties P~1~, P~2~ and P~3~](getting-started.md#safety-properties) stated informally can be expressed in sHML.