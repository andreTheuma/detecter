--8<-- "includes/common.md"

# Runtime Verification
---

## A partial view of the program model

Let us recall the calculator server and its transition model.

--8<-- "includes/model.svg"
{: .center .img }

* DRAW TRACES? *


From its initial state `Q0`, the transition system modelling the behaviour of `#!erlang calc_server:loop/1` can follow different paths.
This *branching* structure is induced by the `#!erlang receive` expression, which introduces a *choice* between the clauses to execute depending on the pattern match that succeeds.
The transition model thus gives us an *exhaustive description* of the paths that the calculator server can take at runtime, affording us *full visibility* about what the program is able do.
Notably, this information is available prior to runtime, and is what certain static verification techniques such as model checking rely upon.
<!-- For example, if the server matches a client request to the pattern XXX, it then replies with the result of the addition, XXX, and loops -->

There are however cases where such approaches cannot be employed, *e.g.* the program transition model is not available or is infeasible to construct.




*Runtime Verification* is a post-deployment technique [] that can be used instead of---or in tandem with---static techniques to increase correctness assurances about a program under scrutiny.

detectEr is a RV tool for asynchronous component systems that can analyse the behaviour of programs running on, or outside the EVM.


{--HERE--}


Often, the runtime setting in constrained to one 



Often, post-deployment verification techniques such as RV, do not have access to the entire execution graph of a SuS, e.g. the transition model in fig. 1b. Instead, these are limited to the trace of (program) events that is generated by the cur- rent execution of the SuS. For instance, an execution might generate the trace of events ‘pid1 ?⟨pid2 ,stp⟩.pid1:pid2 !⟨bye,−1⟩’, that corresponds to the (finite) path traversal Q0 →Srv?⟨Clt,stp⟩→Q3 →Srv:Clt!⟨bye,Tot⟩→Q4 in the transi- tion model of fig. 1b. In traces, events consist of concrete values instead of vari- able placeholders, e.g. pid1 instead of Srv, etc.






**Describe what a trace is.**

Runtime is a different story. 

A sequential program logic such as loop/1 can only choose one path, which is reflected in the program events exhibits.

A path of the model, take from paper.

A trace is a path of the model.

*LINK TO NEXT SECTION*
In the next section we see how a logic that specifies properties on the transition model of the system can also be used to veriify the system at runtime just by looking at sliver of the model, captured in a path of the trace.






## Trace events - From model to trace events

Full model in the diagram, but partial model at runtime.

While the program is a transition system where each program state can simultaneously branch into more than one state, at runtime we only get to observe the program actions in the form of linear sequences of events called traces.


<!-- Actions but say they we use event henceforth since this sounds more natural. -->

Explain how trace events capture the computation of the system.

Give an example of trace events in Erlang

Say that they carry data

List the 5 trace events that we support (so that we link with the logic section)
