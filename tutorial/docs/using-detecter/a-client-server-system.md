
--8<-- "includes/common.md"

# A Client-Server System

# Concurrent programs
---

## Calculator program in Erlang

Let us consider an archetypal calculator program consisting of a single server process that handles client requests for arithmetic computation.
The calculator server blocks and waits for requests sent as *asynchronous* messages.
These messages are addressed to the server using its PID, and deposited in the server mailbox that buffers multiple client requests.
The calculator server unblocks upon reading a message from its mailbox.
In our client-server protocol, messages contain the *type* of operation to be executed on the server side, its *arguments* (if applicable), and the client PID to whom the corresponding server reply is addressed.

Our calculator program is implemented as the Erlang module `#!erlang calc_server` that can be found under `examples/erlang/src`.

```erlang linenums="1"
start() ->
  spawn(?MODULE, loop, [0]).

loop(Tot) ->
  receive
    {Clt, {add, A, B}} ->
      Clt ! {ok, A + B},
      loop(Tot + 1);

    {Clt, {mul, A, B}} ->
      Clt ! {ok, A * B},
      loop(Tot + 1);

    {Clt, stp} -> % Stop service.
      Clt ! {bye, Tot}
  end.
```

`#!erlang calc_server:loop/1` encapsulates the calculator server logic that is [spawned](../getting-started/quickstart.md#hello-world-the-asynchronous-way) by some other launcher process (*e.g.* the Erlang shell) that invokes `#!erlang calc_server:start/0`.

The spawned server consumes one message request from its mailbox via the `#!erlang receive` expression on lines `5-16`, and pattern matches against the three types of operations requested by clients:

1. Addition (`#!erlang add`) and multiplication (`#!erlang mul`) requests that carry the operands `#!erlang A` and `#!erlang B` (lines `6` and `10`), and,

2. stop (`#!erlang stp`) requests that carries no arguments (line `14`).

Pattern matching instantiates the variables `#!erlang Clt`, `#!erlang A` and `#!erlang B` to *concrete data* in client request messages.
Every request fulfilled by the server results in a corresponding reply that it sends to the PID of the client instantiated in variable `#!erlang Clt`, lines `6`, `10`, and `14`.
Server replies carry the status *tag* (an atom) `#!erlang ok` or `#!erlang bye`, and the result of the requested operation.
The server uses the parameter `#!erlang Tot` of `#!erlang loop/1` to track the number of requests serviced, and is returned in reply to a `#!erlang stp` operation.
After handling `#!erlang add` and `#!erlang mul` requests, the server executes `#!erlang loop/1` to recommence the process loop and service the next client request, incrementing the request count accordingly (lines `8` and `12`); the tail recursive call to `#!erlang loop/1` is not made for `#!erlang stp` requests, and the calculator server process terminates naturally.



 


The logic of `#!erlang loop/1` induces a server runtime behaviour that can be abstractly described by the transition






Keywords:
Transition system, states



--8<-- "includes/model.txt"



## Safety Properties = Guarantees


The guarantees we want to hold = properties from the paper.



## Trace events - From model to trace events

While the program is a transition system where each program state can simultaneously branch into more than one state, at runtime we only get to observe the program actions in the form of linear sequences of events called traces.


Actions but say they we use event henceforth since this sounds more natural.

Explain how trace events capture the computation of the system.

Give an example of trace events in Erlang

Say that they carry data

List the 5 trace events that we support


Often, post-deployment verification techniques such as RV, do not have access to the entire execution graph of a SuS, e.g. the transition model in fig. 1b. Instead, these are limited to the trace of (program) events that is generated by the cur- rent execution of the SuS. For instance, an execution might generate the trace of events ‘pid1 ?⟨pid2 ,stp⟩.pid1:pid2 !⟨bye,−1⟩’, that corresponds to the (finite) path traversal Q0 →Srv?⟨Clt,stp⟩→Q3 →Srv:Clt!⟨bye,Tot⟩→Q4 in the transi- tion model of fig. 1b. In traces, events consist of concrete values instead of vari- able placeholders, e.g. pid1 instead of Srv, etc. 



